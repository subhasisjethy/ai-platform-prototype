import { useState } from "react";

interface BookMetadata {
  title: string;
  author: string;
  description: string;
  tags: string[];
  language: string;
  publicationDate?: string;
  publisher?: string;
}

interface RagQuery {
  query: string;
  filters?: {
    author?: string;
    tags?: string[];
    language?: string;
  };
  maxResults?: number;
  temperature?: number;
}

interface RagResponse {
  answer: string;
  sources: {
    title: string;
    author: string;
    excerpt: string;
    relevance: number;
  }[];
  processingTime: number;
}

interface UploadedBook {
  id: string;
  file: File;
  metadata: BookMetadata;
  uploadDate: Date;
  status: "processing" | "ready" | "error";
  error?: string;
}

export function useRag() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [books, setBooks] = useState<UploadedBook[]>([]);
  const [lastResponse, setLastResponse] = useState<RagResponse | null>(null);

  // Mock function to simulate book upload and processing
  const uploadBook = async (
    file: File,
    metadata: BookMetadata,
  ): Promise<UploadedBook> => {
    setIsLoading(true);
    setError(null);

    try {
      // In a real implementation, this would upload to a server
      // and process the book for RAG
      await new Promise((resolve) => setTimeout(resolve, 1500)); // Simulate processing time

      const newBook: UploadedBook = {
        id: `book-${Date.now()}`,
        file,
        metadata,
        uploadDate: new Date(),
        status: "ready",
      };

      setBooks((prevBooks) => [...prevBooks, newBook]);
      return newBook;
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : "Unknown error during upload";
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  // Mock function to simulate RAG query
  const query = async (ragQuery: RagQuery): Promise<RagResponse> => {
    setIsLoading(true);
    setError(null);

    try {
      // In a real implementation, this would send the query to a RAG backend
      await new Promise((resolve) => setTimeout(resolve, 2000)); // Simulate processing time

      // Mock response
      const mockResponse: RagResponse = {
        answer: `This is a simulated answer to the query: "${ragQuery.query}". In a real implementation, this would be generated by a RAG system using the uploaded books as context.`,
        sources: books.slice(0, 2).map((book) => ({
          title: book.metadata.title,
          author: book.metadata.author,
          excerpt: `Excerpt from ${book.metadata.title}...`,
          relevance: Math.random() * 0.5 + 0.5, // Random relevance between 0.5 and 1
        })),
        processingTime: 1.2,
      };

      setLastResponse(mockResponse);
      return mockResponse;
    } catch (err) {
      const errorMessage =
        err instanceof Error ? err.message : "Unknown error during query";
      setError(errorMessage);
      throw new Error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  };

  // Function to get all uploaded books
  const getBooks = () => books;

  // Function to delete a book
  const deleteBook = (bookId: string) => {
    setBooks((prevBooks) => prevBooks.filter((book) => book.id !== bookId));
  };

  return {
    isLoading,
    error,
    books,
    lastResponse,
    uploadBook,
    query,
    getBooks,
    deleteBook,
  };
}
